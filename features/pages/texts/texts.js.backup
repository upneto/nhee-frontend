// Texts Page JS
console.log('Texts page loaded');

// Estado para controle de paginação - usar objeto global para evitar redeclarações
if (!window.textsPageState) {
    window.textsPageState = {};
}

window.textsPageState.currentPage = 1;
window.textsPageState.isLoading = false;
window.textsPageState.hasMorePages = true;
window.textsPageState.currentFilters = {};

// Inicializar dados de domínio para filtros
async function initializeDomainData() {
    try {
        // Carregar áreas de conhecimento para filtro
        const knowledgeAreas = await window.DomainService.getKnowledgeAreas();
        window.DomainService.populateSelect('filterArea', knowledgeAreas, 'Todas as áreas');
        
        // Carregar tipos de texto para filtro
        const textTypes = await window.DomainService.getTextTypes();
        window.DomainService.populateSelect('filterType', textTypes, 'Todos os tipos');
        
        console.log('Filter domain data loaded successfully');
    } catch (error) {
        console.error('Error loading filter domain data:', error);
    }
}

// Função para tentar criar novo texto
function handleNewText() {
    const isLoggedIn = localStorage.getItem('loggedIn') === 'true';
    
    if (!isLoggedIn) {
        alert('Para criar um novo texto, você precisa fazer login primeiro.');
        window.location.hash = 'login';
        return;
    }
    
    // Se autenticado, redirecionar para página de novo texto
    window.location.hash = 'new-text';
}

// Função para limpar filtros
function clearFilters() {
    document.getElementById('searchTexts').value = '';
    document.getElementById('filterArea').value = '';
    document.getElementById('filterType').value = '';
    document.getElementById('filterConcepts').value = '';
    
    // Resetar paginação
    currentPage = 1;
    hasMorePages = true;
    
    // Disparar evento para atualizar lista
    applyFilters();
}

// Função para carregar textos do backend
async function loadTexts(append = false) {
    if (isLoading || (!hasMorePages && append)) {
        return;
    }
    
    try {
        isLoading = true;
        
        const searchTerm = document.getElementById('searchTexts').value.trim();
        const areaFilter = document.getElementById('filterArea').value;
        const typeFilter = document.getElementById('filterType').value;
        const conceptFilter = document.getElementById('filterConcepts').value.trim();
        
        // Construir filtros
        const filters = {
            page: append ? currentPage : 1,
            limit: 10,
            sortBy: 'questions_count,authenticity_score',
            sortOrder: 'desc'
        };
        
        if (searchTerm) filters.search = searchTerm;
        if (areaFilter) filters.area = areaFilter;
        if (typeFilter) filters.type = typeFilter;
        if (conceptFilter) filters.concept = conceptFilter;
        
        currentFilters = { ...filters };
        
        console.log('Carregando textos com filtros:', filters);
        
        // Mostrar loading no final da lista se estiver fazendo append
        if (append) {
            showLoadingIndicator();
        }
        
        // Buscar textos da API
        const response = await window.TextService.list(filters);
        
        if (response && response.data) {
            const { pagination } = response;
            
            // Atualizar controle de paginação
            hasMorePages = pagination.page < pagination.totalPages;
            
            if (append) {
                appendTexts(response.data);
            } else {
                currentPage = 1;
                hasMorePages = pagination.totalPages > 1;
                renderTexts(response.data);
            }
            
            if (append) {
                currentPage++;
            }
        } else {
            if (!append) {
                renderTexts([]);
            }
            hasMorePages = false;
        }
    } catch (error) {
        console.error('Erro ao carregar textos:', error);
        const textsList = document.getElementById('textsList');
        if (textsList && !append) {
            textsList.innerHTML = `
                <div class="alert alert-warning" style="background-color: #2d1a1a; border-color: #d4af37; color: #f5d76e;">
                    <strong>Erro ao carregar textos.</strong> Por favor, tente novamente.
                </div>
            `;
        }
        hasMorePages = false;
    } finally {
        isLoading = false;
        hideLoadingIndicator();
    }
}

// Função para renderizar lista de textos
function renderTexts(texts) {
    const textsList = document.getElementById('textsList');
    
    if (!textsList) return;
    
    if (!texts || texts.length === 0) {
        textsList.innerHTML = `
            <div class="alert" style="background-color: #2d1a1a; border-color: #d4af37; color: #f5d76e; text-align: center; padding: 40px;">
                <h5 style="color: #d4af37; margin-bottom: 10px;">Nenhum texto encontrado</h5>
                <p>Tente ajustar os filtros ou seja o primeiro a criar um texto!</p>
            </div>
        `;
        return;
    }
    
    const textsHTML = texts.map(text => {
        const preview = text.content ? text.content.substring(0, 200) + '...' : '';
        const tags = Array.isArray(text.tags) ? text.tags : (text.tags ? text.tags.split(',') : []);
        const questionsCount = text.questions_count || 0;
        const authenticityScore = (text.authenticity_score !== null && text.authenticity_score !== undefined && !isNaN(text.authenticity_score)) 
            ? Number(text.authenticity_score).toFixed(1) 
            : 'N/A';
        const createdDate = new Date(text.created_at).toLocaleDateString('pt-BR', { 
            day: 'numeric', 
            month: 'long', 
            year: 'numeric' 
        });
        
        return `
            <div class="text-card" style="background: linear-gradient(145deg, #1a1a1a 0%, #0d0d0d 100%); padding: 30px; margin-bottom: 25px; border-radius: 4px; border: 1px solid #2d2d2d;">
                <h3 style="color: #d4af37; margin-bottom: 15px;">${text.title}</h3>
                <p style="color: #999; font-size: 14px; margin-bottom: 15px;">
                    <span style="color: #b8935e;">Por: ${text.author_username || 'Anônimo'}</span> | 
                    <span>${createdDate}</span> | 
                    <span style="color: #d4af37;">${questionsCount} dúvidas</span> |
                    <span class="authenticity-badge-list" style="color: #b8935e; font-size: 12px; display: inline-block;">
                        Autenticidade: <strong style="color: #d4af37; font-size: 13px;">${authenticityScore}</strong>/10
                    </span>
                </p>
                <p style="color: #cccccc; line-height: 1.8; margin-bottom: 20px;">
                    ${preview}
                </p>
                <div style="margin-bottom: 15px;">
                    ${tags.map(tag => `
                        <span class="badge" style="background-color: #0d0d0d; color: #b8935e; margin-right: 8px; padding: 5px 12px; border: 1px solid #2d2d2d;">${tag.trim()}</span>
                    `).join('')}
                </div>
                <a href="#text-view" class="btn btn-sm" style="background-color: #2d2d2d; color: #d4af37; border: 1px solid #404040; text-decoration: none;" onclick="viewText(${text.id})">Ler Texto Completo</a>
                <a href="#text-view" class="btn btn-sm" style="background-color: #2d2d2d; color: #d4af37; border: 1px solid #404040; text-decoration: none; margin-left: 10px;" onclick="viewText(${text.id})">Ver Dúvidas/Críticas (${questionsCount})</a>
            </div>
        `;
    }).join('');
    
    textsList.innerHTML = textsHTML;
}

// Função para adicionar textos à lista existente (scroll infinito)
function appendTexts(texts) {
    const textsList = document.getElementById('textsList');
    
    if (!textsList || !texts || texts.length === 0) {
        return;
    }
    
    const textsHTML = texts.map(text => {
        const preview = text.content ? text.content.substring(0, 200) + '...' : '';
        const tags = Array.isArray(text.tags) ? text.tags : (text.tags ? text.tags.split(',') : []);
        const questionsCount = text.questions_count || 0;
        const authenticityScore = (text.authenticity_score !== null && text.authenticity_score !== undefined && !isNaN(text.authenticity_score)) 
            ? Number(text.authenticity_score).toFixed(1) 
            : 'N/A';
        const createdDate = new Date(text.created_at).toLocaleDateString('pt-BR', { 
            day: 'numeric', 
            month: 'long', 
            year: 'numeric' 
        });
        
        return `
            <div class="text-card" style="background: linear-gradient(145deg, #1a1a1a 0%, #0d0d0d 100%); padding: 30px; margin-bottom: 25px; border-radius: 4px; border: 1px solid #2d2d2d;">
                <h3 style="color: #d4af37; margin-bottom: 15px;">${text.title}</h3>
                <p style="color: #999; font-size: 14px; margin-bottom: 15px;">
                    <span style="color: #b8935e;">Por: ${text.author_username || 'Anônimo'}</span> | 
                    <span>${createdDate}</span> | 
                    <span style="color: #d4af37;">${questionsCount} dúvidas</span> |
                    <span class="authenticity-badge-list" style="color: #b8935e; font-size: 12px; display: inline-block;">
                        Autenticidade: <strong style="color: #d4af37; font-size: 13px;">${authenticityScore}</strong>/10
                    </span>
                </p>
                <p style="color: #cccccc; line-height: 1.8; margin-bottom: 20px;">
                    ${preview}
                </p>
                <div style="margin-bottom: 15px;">
                    ${tags.map(tag => `
                        <span class="badge" style="background-color: #0d0d0d; color: #b8935e; margin-right: 8px; padding: 5px 12px; border: 1px solid #2d2d2d;">${tag.trim()}</span>
                    `).join('')}
                </div>
                <a href="#text-view" class="btn btn-sm" style="background-color: #2d2d2d; color: #d4af37; border: 1px solid #404040; text-decoration: none;" onclick="viewText(${text.id})">Ler Texto Completo</a>
                <a href="#text-view" class="btn btn-sm" style="background-color: #2d2d2d; color: #d4af37; border: 1px solid #404040; text-decoration: none; margin-left: 10px;" onclick="viewText(${text.id})">Ver Dúvidas/Críticas (${questionsCount})</a>
            </div>
        `;
    }).join('');
    
    // Remove loading indicator antes de adicionar
    const loadingIndicator = document.getElementById('loadingIndicator');
    if (loadingIndicator) {
        loadingIndicator.remove();
    }
    
    textsList.insertAdjacentHTML('beforeend', textsHTML);
}

// Mostrar indicador de carregamento
function showLoadingIndicator() {
    const textsList = document.getElementById('textsList');
    if (!textsList) return;
    
    // Remove indicador existente se houver
    const existing = document.getElementById('loadingIndicator');
    if (existing) existing.remove();
    
    const loadingHTML = `
        <div id="loadingIndicator" class="text-center" style="padding: 30px; color: #d4af37;">
            <div class="spinner-border" role="status" style="color: #d4af37;">
                <span class="visually-hidden">Carregando...</span>
            </div>
            <p style="margin-top: 15px; color: #999;">Carregando mais textos...</p>
        </div>
    `;
    
    textsList.insertAdjacentHTML('beforeend', loadingHTML);
}

// Ocultar indicador de carregamento
function hideLoadingIndicator() {
    const loadingIndicator = document.getElementById('loadingIndicator');
    if (loadingIndicator) {
        loadingIndicator.remove();
    }
}

// Detectar scroll e carregar mais textos
function handleScroll() {
    if (isLoading || !hasMorePages) return;
    
    const scrollHeight = document.documentElement.scrollHeight;
    const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
    const clientHeight = document.documentElement.clientHeight;
    
    // Carregar mais quando estiver a 300px do final
    if (scrollHeight - scrollTop - clientHeight < 300) {
        loadTexts(true);
    }
}

// Função para visualizar texto
function viewText(textId) {
    localStorage.setItem('viewingTextId', textId);
    // O hash já é alterado pelo link
}

// Função para aplicar filtros (agora chama loadTexts)
function applyFilters() {
    // Resetar paginação quando filtros mudam
    currentPage = 1;
    hasMorePages = true;
    loadTexts(false);
}

// Tornar funções globais
window.handleNewText = handleNewText;
window.clearFilters = clearFilters;
window.applyFilters = applyFilters;
window.viewText = viewText;

// Função de inicialização da página
async function initTextsPage() {
    console.log('Initializing texts page...');
    
    // Resetar estado global
    window.textsPageState.currentPage = 1;
    window.textsPageState.isLoading = false;
    window.textsPageState.hasMorePages = true;
    window.textsPageState.currentFilters = {};
    
    // Atualizar referências locais
    currentPage = 1;
    isLoading = false;
    hasMorePages = true;
    currentFilters = {};
    
    // Inicializar dados de domínio para os filtros
    await initializeDomainData();
    
    // Verificar se há filtro de conceito no localStorage
    const filterConcept = localStorage.getItem('filterConcept');
    if (filterConcept) {
        // Aplicar filtro
        const searchInput = document.getElementById('searchTexts');
        if (searchInput) {
            searchInput.value = filterConcept;
            // Disparar evento de busca
            searchInput.dispatchEvent(new Event('input'));
        }
        // Limpar filtro do localStorage
        localStorage.removeItem('filterConcept');
        
        // Scroll suave para os resultados
        setTimeout(() => {
            const textsList = document.getElementById('textsList');
            if (textsList) {
                textsList.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }, 100);
    }

    // Verificar se usuário está autenticado
    const isLoggedIn = localStorage.getItem('loggedIn') === 'true';
    const authWarning = document.getElementById('authWarning');
    const newTextContainer = document.getElementById('newTextContainer');

    console.log('Auth check:', isLoggedIn);
    console.log('Elements:', { authWarning, newTextContainer });

    // Mostrar aviso se não estiver autenticado, ou botão se estiver
    if (!isLoggedIn && authWarning) {
        authWarning.style.display = 'block';
    }
    
    if (isLoggedIn && newTextContainer) {
        newTextContainer.style.display = 'block';
        console.log('Botão Novo Texto exibido');
    }

    // Busca de textos
    const searchInput = document.getElementById('searchTexts');
    if (searchInput) {
        searchInput.addEventListener('input', applyFilters);
    }

    // Event listeners para filtros
    const filterArea = document.getElementById('filterArea');
    const filterType = document.getElementById('filterType');
    const filterConcepts = document.getElementById('filterConcepts');

    if (filterArea) filterArea.addEventListener('change', applyFilters);
    if (filterType) filterType.addEventListener('change', applyFilters);
    if (filterConcepts) filterConcepts.addEventListener('input', applyFilters);

    // Clique em tags/conceitos
    const conceptTags = document.querySelectorAll('#conceptTags .badge');
    conceptTags.forEach(tag => {
        tag.addEventListener('click', function() {
            const concept = this.textContent;
            const filterInput = document.getElementById('filterConcepts');
            if (filterInput) {
                filterInput.value = concept;
                applyFilters();
            }
        });
    });
    
    // Carregar textos inicialmente
    loadTexts(false);
    
    // Adicionar listener de scroll para infinite scroll
    window.addEventListener('scroll', handleScroll);
}

// Executar inicialização quando DOM estiver pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTextsPage);
} else {
    // DOM já está pronto, executar imediatamente
    setTimeout(initTextsPage, 100);
}